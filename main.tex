% FORMAT AND PACKAGES
% {
\documentclass[a4paper]{article}
\usepackage{a4wide,amssymb,epsfig,latexsym,multicol,array,hhline,fancyhdr}
\usepackage{vntex}
\usepackage{amsmath}
\usepackage{lastpage}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{enumerate}
\usepackage{xcolor}
\usepackage{graphicx}							% Standard graphics package
\usepackage{array}
\usepackage{tabularx, caption}
\usepackage{multirow}
\usepackage{array} % để chỉnh cột
\newcounter{rownum} % tạo counter
\usepackage{multicol}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{epsfig}
\usepackage{tikz}
\usepackage{xfrac}
\usepackage{bm}
\usepackage{biblatex}
\usepackage[colorlinks]{hyperref}
% \usepackage[acronym,toc]{glossaries}
% \usepackage[symbols,nogroupskip,nonumberlist]{glossaries-extra}
\usepackage[
 sort=none,% no sorting or indexing required
 abbreviations,% create list of abbreviations
 symbols,% create list of symbols
 stylemods,style=list, % set the default glossary style
 nogroupskip, nonumberlist, nomain
]{glossaries-extra}
\usepackage{float}

% FORMATTING
% {
\DeclareMathOperator{\arccot}{arccot}
\captionsetup[table]{name=Bảng}
\captionsetup[figure]{name=Hình}
\newenvironment{Description}{\list{}{%
    \let\makelabel\descriptionlabel    % this comes from the original description environment
    \setlength{\rightmargin}{\leftmargin}% this comes from the original quote environment
    \setlength{\labelwidth}{0pt}%          this is new
    }}{\endlist}

\addbibresource{citations.bib}
    
\hypersetup{urlcolor=blue,linkcolor=black,citecolor=black,colorlinks=true} 
\usetikzlibrary{arrows,snakes,backgrounds}
\definecolor{mathblue}{RGB}{0,114,188}
% \makeatletter  \def\m@th{\mathsurround\z@\color{mathblue}} \makeatother
% \everymath{\color{mathblue}}
% \setmathfont[Color=000000]{Arial}
%\usepackage{pstcol} 								% PSTricks with the standard color package
\newtheorem{theorem}{{\bf Theorem}}
\newtheorem{property}{{\bf Property}}
\newtheorem{proposition}{{\bf Proposition}}
\newtheorem{corollary}[proposition]{{\bf Corollary}}
\newtheorem{lemma}[proposition]{{\bf Lemma}}

\AtBeginDocument{\renewcommand{\listfigurename}{Danh sách hình ảnh}}
\AtBeginDocument{\renewcommand{\listtablename}{Danh sách bảng}}
\AtBeginDocument{\renewcommand*\contentsname{Mục lục}}
\AtBeginDocument{\renewcommand*\refname{References}}
%\usepackage{fancyhdr}

\setlength{\headheight}{40pt}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{
 \begin{tabular}{rl}
    \begin{picture}(25,15)(0,0)
    \put(0,-8){\includegraphics[width=8mm, height=8mm]{01_logobachkhoasang.png}}
    %\put(0,-8){\epsfig{width=10mm,figure=hcmut.eps}}
   \end{picture}&
	%\includegraphics[width=8mm, height=8mm]{hcmut.png} & %
	\begin{tabular}{l}
		\textbf{\bf \ttfamily Trường Đại học Bách khoa - ĐHQG-HCM}\\
		\textbf{\bf \ttfamily Khoa Khoa học và Kỹ thuật Máy tính}
	\end{tabular} 	
 \end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{l}
		\tiny \bf \\
		\tiny \bf 
	\end{tabular}  }
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\scriptsize \ttfamily Bài tập nhóm Mạng máy tính - Năm học 2025 - 2026}
\fancyfoot[R]{\scriptsize \ttfamily Trang {\thepage}/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0.3pt}
\renewcommand{\footrulewidth}{0.3pt}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\makeatletter
\newcounter {subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection .\@alph\c@subsubsubsection}
\newcommand\subsubsubsection{\@startsection{subsubsubsection}{4}{\z@}%
                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
\newcommand*\l@subsubsubsection{\@dottedtocline{3}{10.0em}{4.1em}}
\newcommand*{\subsubsubsectionmark}[1]{}
% \def\m@th{\mathsurround\z@\color{mathblue}}
\makeatother
% }
% }

% ACRONYMS & SYMBOLS
% {
% \makeglossaries
\setabbreviationstyle{long-short}
% \newabbreviation{ode}{ODE}{(First-Order) Ordinary Differential Equation}
% \newabbreviation{ivp}{IVP}{Initial-Value Problem}
% \newabbreviation{lte}{LTE}{Local Truncation Error}
% \newabbreviation{ds}{DS}{Dynamical System}
\newabbreviation{fig}{Fig.}{Figure}
\newabbreviation{tab}{Tab.}{Table}
% \newabbreviation{sys}{Sys.}{System of Equations}
% \newabbreviation{eq}{Eq.}{Equation}
\newabbreviation{eg}{e.g.}{For Example}
\newabbreviation{ie}{i.e.}{That Is}


% \newabbreviation{ai}{AI}{Artificial Intelligence}
% \newabbreviation{ml}{ML}{Machine Learning}
% \newabbreviation{dl}{DL}{Deep Learning}
% \newabbreviation{eda}{EDA}{Exploratory Data Analysis}
% \newabbreviation{iid}{IID}{Independent and Identically Distributed}
% \newabbreviation{knn}{KNN}{K-Nearest Neighbors}
% \newabbreviation{svm}{SVM}{Support Vector Machine}
% \newabbreviation{pca}{PCA}{Principal Component Analysis}
% \newabbreviation{mlp}{MLP}{Multilayer Perceptron}
% \newabbreviation{sgd}{SGD}{Stochastic Gradient Descent}
% \newabbreviation{mse}{MSE}{Mean Squared Error}

\usepackage{longtable}
\newcommand{\rownumber}{\stepcounter{rownum}\arabic{rownum}}

% \glsnoexpandfields
\glsxtrnewsymbol[description = {Set of natural numbers}]{natural}{\ensuremath{\mathbb{N}}}
\glsxtrnewsymbol[description = {Set of real numbers}]{real}{\ensuremath{\mathbb{R}}}
\glsxtrnewsymbol[description = {Set of positive real numbers}]{real_positive}{\ensuremath{\mathbb{R}^+}}

% }

% DOCUMENT
\begin{document}

% TITLE PAGE
\begin{titlepage}
    \begin{center}
        ĐẠI HỌC QUỐC GIA THÀNH PHỐ HỒ CHÍ MINH \\
        TRƯỜNG ĐẠI HỌC BÁCH KHOA \\
        KHOA KHOA HỌC VÀ KỸ THUẬT MÁY TÍNH
    \end{center}
    
    \vspace{1cm}
    
    \begin{figure}[h!]
        \begin{center}
            \includegraphics[width=3cm]{01_logobachkhoasang.png}
        \end{center}
    \end{figure}
    
    \vspace{1cm}
    
    
\begin{center}
\begin{tabular}{c}
\multicolumn{1}{c}{\textbf{{\Large Lớp TN01 - Nhóm 8386}}}\\
~~\\
\hline
\\
\multicolumn{1}{l}{\textbf{{\Large Bài tập nhóm tuần 4 - bài 1}}}\\
\\
\textbf{\textit{{\Huge Mạng máy tính (CO3094)}}}\\
\\
\hline
\end{tabular}
\end{center}

\vspace{1cm}
\begin{center}
\textbf{\textit{\Large ``Deep Dive into Docker Networking''}}
    
\end{center}
\vspace{0.5cm}

\begin{table}[h]
\centering
    \begin{tabular}{rl}
    \hspace{3 cm}\textbf{Giảng viên hướng dẫn}:
    & Hoàng Lê Hải Thanh\\

    & \\[10pt]
    \textbf{Sinh viên thực hiện}: &  Lê Nguyễn Kim Khôi - 2311671  \\
    &  Bùi Ngọc Phúc - 2312665  \\
    &  Phạm Trần Minh Trí - 2313622\\
    &  Lê Trọng Thiện - 2313233\\
    &  Nguyễn Công Minh - 2312080 \\
    \end{tabular}
\end{table}

\begin{center}
{\footnotesize THÀNH PHỐ HỒ CHÍ MINH, 12/2025}
\end{center}
\end{titlepage}

\pagebreak
\tableofcontents

\section{Virtualization, Docker và Vai trò của Mạng Máy Tính}

\subsection{Virtualization là gì? Docker khác gì máy ảo truyền thống}

Virtualization (ảo hoá) là kỹ thuật cho phép chạy nhiều hệ điều hành và ứng dụng khác nhau trên cùng một máy vật lý, bằng cách chia sẻ tài nguyên thông qua một lớp phần mềm trung gian gọi là \textit{hypervisor}. Hypervisor tạo ra các máy ảo (Virtual Machines -- VMs), mỗi VM có hệ điều hành riêng, không gian tiến trình riêng và tài nguyên ảo hoá (CPU, RAM, ổ đĩa, thiết bị mạng) tách biệt với các VM khác. Mô hình này giúp tận dụng tốt hơn phần cứng vật lý, triển khai linh hoạt nhiều hệ thống mà không cần nhiều máy chủ thật.

Docker cũng là một công nghệ ảo hoá, nhưng hoạt động ở cấp độ hệ điều hành thay vì ảo hoá toàn bộ phần cứng như VM. Thay vì khởi động một hệ điều hành khách (guest OS) riêng, Docker sử dụng kernel của hệ điều hành host và cô lập ứng dụng bằng các cơ chế như \textit{namespaces}, \textit{cgroups} và \textit{filesystem layers}. Mỗi \textit{container} vì vậy nhẹ hơn rất nhiều so với một VM, khởi động gần như tức thì, và chia sẻ phần lớn thư viện hệ thống với host.

Điểm khác biệt quan trọng giữa Docker và VM có thể tóm tắt như sau. Thứ nhất, VM ảo hoá phần cứng rồi chạy một hệ điều hành đầy đủ, trong khi Docker ảo hoá môi trường chạy ứng dụng trên một hệ điều hành chung. Thứ hai, mỗi VM cần một image hệ điều hành lớn, khởi động lâu và tốn tài nguyên; còn container thường nhỏ, khởi chạy nhanh, phù hợp với mô hình triển khai linh hoạt và mở rộng theo nhu cầu. Thứ ba, mức độ cô lập của VM thường mạnh hơn vì mỗi VM có kernel riêng, trong khi container chia sẻ kernel với host nên cần chú ý hơn tới cấu hình bảo mật.

\subsection{Vì sao containerization được sử dụng rộng rãi hiện nay}

Containerization được sử dụng rộng rãi vì mang lại nhiều lợi ích rõ ràng so với cách triển khai ứng dụng truyền thống và cả so với VM. Một lợi ích quan trọng là \textit{tính di động} (portability): ứng dụng và toàn bộ phụ thuộc được đóng gói trong một image, nên có thể chạy nhất quán trên máy cá nhân, máy chủ on-premise hoặc môi trường cloud khác nhau mà không lo xung đột môi trường. Điều này rất phù hợp với mô hình phát triển hiện đại, nơi developer, tester và production đều dùng cùng một image.
Thứ hai, container giúp \textit{tăng hiệu quả sử dụng tài nguyên} do chia sẻ kernel và một phần thư viện với host, cho phép chạy nhiều container trên cùng một máy vật lý hơn so với số lượng VM tương đương. Điều này giúp giảm chi phí phần cứng và chi phí cloud. Thứ ba, container hỗ trợ \textit{triển khai nhanh} và \textit{tự động hoá} trong các pipeline CI/CD: việc build image, push lên registry và deploy đến nhiều môi trường có thể được kịch bản hoá một cách dễ dàng, rút ngắn thời gian đưa tính năng mới ra thị trường.

Ngoài ra, containerization hỗ trợ rất tốt cho kiến trúc microservices, nơi một hệ thống lớn được chia thành nhiều dịch vụ nhỏ, độc lập, có thể scale riêng, cập nhật riêng và deploy riêng. Khả năng tạo, nhân bản, nâng cấp và huỷ container nhanh chóng giúp các đội ngũ DevOps vận hành hệ thống phức tạp với độ tin cậy cao hơn.

\subsection{Kiến thức mạng giúp kỹ sư thiết kế và triển khai hệ thống thật như thế nào}

Kiến thức mạng máy tính đóng vai trò cốt lõi khi kỹ sư sử dụng Docker để xây dựng và triển khai hệ thống thực tế. Mỗi container đều giao tiếp với các container khác, với host và với mạng bên ngoài thông qua các cơ chế như bridge networks, port mapping, overlay networks hay các giải pháp như VPN và reverse proxy. Nếu không hiểu các khái niệm cơ bản như địa chỉ IP, subnet, routing, NAT, DNS, firewall hay các giao thức như TCP/UDP và HTTP, việc thiết kế kiến trúc mạng cho hệ thống container sẽ trở nên rất khó khăn.

Cụ thể, khi triển khai một hệ thống microservices, kỹ sư cần quyết định container nào được expose ra Internet, container nào chỉ giao tiếp nội bộ, cách cấu hình port mapping, cách dùng reverse proxy hoặc API gateway và cách đặt rules firewall để giới hạn lưu lượng. Kiến thức về mạng giúp họ đảm bảo hệ thống vừa \textit{kết nối tốt} (các dịch vụ nói chuyện với nhau đúng port, đúng IP, đúng giao thức) vừa \textit{an toàn} (không mở thừa port, không để lộ dịch vụ nội bộ ra ngoài, hạn chế tấn công như scan port hay sniffing).
Bên cạnh đó, hiểu về latency, throughput, packet loss và congestion cũng rất quan trọng để tối ưu hiệu năng. Trong hệ thống phân tán, nhiều container có thể chạy trên các máy khác nhau, liên lạc qua mạng LAN hoặc Internet. Kiến thức mạng cho phép kỹ sư đánh giá đường đi của gói tin, phát hiện nút cổ chai, và chọn giải pháp phù hợp (ví dụ: dùng overlay network, VPN, load balancer, hay message broker) để cân bằng giữa hiệu năng, độ tin cậy và bảo mật.

\subsection{Các công ty và công nghệ sử dụng Docker rộng rãi}

Trong thực tế, rất nhiều công ty công nghệ lớn đã và đang dựa vào Docker như một phần quan trọng của hạ tầng. Các nền tảng streaming như Netflix sử dụng container để chạy hàng loạt dịch vụ backend phục vụ nội dung cho hàng triệu người dùng, kết hợp với các công cụ orchestrator để tự động scale theo tải. Các công ty gọi xe như Uber triển khai hàng trăm microservices dưới dạng container để đảm bảo khả năng mở rộng linh hoạt theo nhu cầu di chuyển của người dùng.

Trong lĩnh vực thương mại điện tử, các nền tảng lớn như Shopify hay nhiều sàn thương mại điện tử khác sử dụng Docker để xử lý lượng truy cập tăng vọt vào các dịp cao điểm, đồng thời giảm rủi ro khi cập nhật tính năng mới. Trong mảng thanh toán và tài chính, các tổ chức như PayPal hay các ngân hàng sử dụng container để xây dựng pipeline CI/CD an toàn và tuân thủ quy định, cho phép phát hành bản cập nhật nhanh nhưng vẫn kiểm soát được môi trường chạy.

Bên cạnh các công ty cụ thể, nhiều công nghệ và nền tảng hiện đại cũng dựa mạnh vào Docker. Kubernetes, một hệ thống orchestration phổ biến, sử dụng container (thường là Docker hoặc container runtime tương thích) để quản lý việc deploy, scale và cập nhật ứng dụng trên cụm máy chủ. Các nền tảng CI/CD như GitLab CI, GitHub Actions, CircleCI hay các PaaS như Heroku, OpenShift, nhiều dịch vụ của các nhà cung cấp cloud lớn đều hỗ trợ hoặc dựa trên Docker images để cung cấp môi trường build và chạy ứng dụng tiêu chuẩn, dễ tái sử dụng và dễ mở rộng.

\section{Phân tích các chế độ mạng của Docker}

Trong phần này, ta sẽ nghiên cứu và đánh giá các chế độ mạng chính của Docker: \textit{bridge}, \textit{host}, \textit{overlay}, \textit{macvlan}, \textit{port mapping}, và \textit{giao tiếp container--container}. Với mỗi chế độ, ta lần lượt trình bày cách hoạt động, trường hợp sử dụng điển hình, ưu điểm và nhược điểm, các lỗi cấu hình thường gặp, và các lưu ý về bảo mật.

\subsection{Bridge Network}

\subsubsection*{Cách hoạt động}
Khi cài Docker, daemon sẽ tạo một \textit{virtual bridge} mặc định (thường là \texttt{docker0}) trên host, đóng vai trò như một switch ảo lớp 2. Mỗi container được gắn vào bridge sẽ nhận một địa chỉ IP riêng trong subnet của bridge, và Docker sử dụng NAT để cho phép container truy cập ra ngoài mạng (LAN/Internet).

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Môi trường phát triển hoặc thử nghiệm trên một máy, nơi nhiều container (web, API, database) cần giao tiếp nội bộ nhưng chỉ một vài dịch vụ cần được publish ra ngoài.
  \item Ứng dụng đơn host, microservices chạy trên cùng một máy, không cần multi-host clustering.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
  \item Cô lập tương đối tốt giữa các ứng dụng: container trong một bridge network riêng không thấy được container ở network khác.
  \item Hỗ trợ DNS nội bộ, cho phép container gọi nhau bằng hostname thay vì IP.
  \item Là chế độ mặc định, cấu hình đơn giản, phù hợp cho người mới dùng Docker.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Chỉ hoạt động trong phạm vi một host, không hỗ trợ multi-host.
  \item Cần thêm một lớp NAT nên việc debug routing/port có thể phức tạp hơn, độ trễ tăng nhẹ.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Container không ping được nhau do nằm ở các network khác nhau hoặc subnet trùng với mạng vật lý; cần kiểm tra \texttt{docker network inspect}, IP range và bảng định tuyến.
  \item Lỗi trùng port khi publish service ra ngoài, container không start được hoặc service không nghe đúng port; cần kiểm tra bằng \texttt{docker ps}, \texttt{docker port}.
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Container trong cùng một bridge network có thể truy cập lẫn nhau; nếu muốn hạn chế cần dùng iptables hoặc cấu hình để tắt inter-container communication.
  \item Nên dùng user-defined bridge thay vì default bridge để tách biệt môi trường (dev/test/prod) và quản lý DNS nội bộ tốt hơn.
\end{itemize}

\subsection{Host Network}

\subsubsection*{Cách hoạt động}
Ở chế độ \textit{host}, container không có network namespace riêng mà dùng chung stack mạng với host. Container không nhận IP riêng; mọi socket nó mở sẽ gắn trực tiếp vào IP và port của host.

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Ứng dụng cần hiệu năng mạng tối đa, ví dụ xử lý gói tin thời gian thực, hệ thống monitoring, load balancer.
  \item Các dịch vụ cần sử dụng nhiều port phức tạp, nơi việc cấu hình port mapping sẽ rối rắm.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
  \item Không có overhead NAT, hiệu năng mạng gần như chạy trực tiếp trên host.
  \item Cấu hình đơn giản với các ứng dụng vốn dĩ được thiết kế để chạy trực tiếp trên máy chủ.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Mất network isolation: container và host chia sẻ cùng network namespace.
  \item Dễ xảy ra xung đột port giữa nhiều container hoặc giữa container với process trên host.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Lỗi thường gặp là một container dùng host network chiếm port của host, khiến service khác không bind được; cần kiểm tra port đang dùng bằng \texttt{ss} hoặc \texttt{netstat}.
  \item Một số môi trường ảo hoá hoặc Docker Desktop giới hạn việc dùng host network, có thể gây lỗi khó hiểu.
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Nếu container bị tấn công, attacker gần như có quyền truy cập mạng giống như trên host, nên rủi ro cao hơn so với bridge.
  \item Không nên dùng host network cho dịch vụ không tin cậy hoặc môi trường multi-tenant; cần kết hợp firewall, phân quyền user và hardening container.
\end{itemize}

\subsection{Overlay Network}

\subsubsection*{Cách hoạt động}
Overlay network sử dụng kỹ thuật encapsulation (thường là VXLAN) để tạo một mạng ảo chạy chồng lên mạng vật lý, kết nối nhiều Docker host với nhau. Khi dùng Docker Swarm, overlay networks được quản lý bởi control plane, cho phép container trên các node khác nhau giao tiếp như thể chúng đang ở cùng một subnet.

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Hệ thống microservices chạy trên nhiều máy vật lý hoặc VM, cần giao tiếp nội bộ mà không muốn tự cấu hình routing phức tạp.
  \item Môi trường học/lab về hệ thống phân tán hoặc Docker Swarm, nơi cần multi-host networking.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
\item Cho phép container trên nhiều host khác nhau giao tiếp dễ dàng, ẩn chi tiết mạng vật lý bên dưới.
  \item Tích hợp sẵn service discovery trong Swarm, có thể gọi nhau bằng service name.
  \item Có thể bật mã hoá traffic giữa các node để tăng bảo mật.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Cấu hình phức tạp hơn bridge, đòi hỏi bật Swarm mode hoặc dùng orchestrator.
  \item Encapsulation gây thêm overhead, có thể làm tăng latency và giảm throughput trong một số tình huống.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Cần mở đúng các port (2377/TCP, 7946/TCP+UDP, 4789/UDP) giữa các node; nếu firewall chặn, các service sẽ không giao tiếp được dù vẫn hiển thị là chạy.
  \item Lỗi join swarm sai token, node không tham gia đúng cluster làm cho container trên node đó không thấy được các service khác.
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Nếu không bật mã hoá, traffic overlay vẫn có thể bị sniff nếu attacker có quyền trên mạng vật lý.
  \item Cần bảo vệ Swarm join token và quản lý chặt chẽ danh sách node tham gia cluster.
\end{itemize}

\subsection{MACVLAN Network}

\subsubsection*{Cách hoạt động}
MACVLAN cho phép gán cho mỗi container một địa chỉ MAC riêng trên interface vật lý (hoặc interface cha), khiến container xuất hiện như một máy riêng trên mạng LAN. Container nhận địa chỉ IP trực tiếp từ subnet của mạng vật lý, không dùng subnet riêng của Docker.

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Khi cần tích hợp container với hệ thống legacy, các thiết bị IoT, router, switch, yêu cầu thiết bị có IP thật trong cùng VLAN.
  \item Môi trường lab mạng, mô phỏng nhiều host vật lý sử dụng ít máy thật.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
  \item Container có IP độc lập trên mạng LAN, không cần NAT, dễ tích hợp với hạ tầng hiện có.
  \item Phù hợp cho các kịch bản cần broadcast, ARP hay các giao thức lớp 2.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Cấu hình phức tạp hơn, phụ thuộc vào cấu hình switch, VLAN và card mạng.
  \item Host thường không giao tiếp trực tiếp với container MACVLAN nếu không tạo thêm interface MACVLAN trên host và cấu hình route.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Dễ gặp lỗi không ping được container từ host do giới hạn của Linux kernel; phải tạo một MACVLAN interface trên host và thiết lập route phù hợp.
\item Có thể bị chặn bởi các cơ chế \textit{port security} trên switch (giới hạn số MAC trên một port).
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Container MACVLAN “lộ” trực tiếp ra mạng vật lý; nếu bị tấn công, attacker có thể tấn công các thiết bị trong LAN như từ một host thật.
  \item Container MACVLAN cũng có thể tham gia hoặc là nạn nhân của tấn công lớp 2 (ARP spoofing, sniffing) nếu mạng không được bảo vệ tốt.
\end{itemize}

\subsection{Port Mapping (Port Publishing)}

\subsubsection*{Cách hoạt động}
Port mapping ánh xạ một port trên host (hoặc \texttt{IP:port} trên host) tới port bên trong container, sử dụng NAT và iptables để chuyển hướng traffic. Cú pháp phổ biến là \texttt{-p host\_port:container\_port} hoặc \texttt{-p host\_ip:host\_port:container\_port}.

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Expose dịch vụ web từ container ra ngoài: ví dụ \texttt{-p 8080:80} cho phép truy cập ứng dụng qua \texttt{http://host:8080}.
  \item Chạy nhiều container cùng loại dịch vụ trên một host, mỗi container dùng một port host khác nhau.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
  \item Dễ sử dụng, linh hoạt, là cách phổ biến để “mở” dịch vụ trong container ra ngoài.
  \item Có thể giới hạn access bằng cách bind vào \texttt{127.0.0.1} hoặc một IP cụ thể của host.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Cần quản lý cẩn thận để tránh xung đột port; khi số dịch vụ nhiều, việc nhớ port trở nên khó khăn.
  \item NAT có thể khiến việc debug mạng phức tạp hơn.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Lỗi \textit{port already allocated} khi port host đã được dùng; phải kiểm tra container đang chạy và các dịch vụ trên host.
  \item Dễ nhầm giữa \texttt{ports} và \texttt{expose} trong Docker Compose: \texttt{ports} publish ra host, \texttt{expose} chỉ dùng nội bộ giữa các container.
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Mỗi port được publish ra ngoài là một bề mặt tấn công; chỉ nên mở port cần thiết và kết hợp firewall để hạn chế nguồn truy cập.
  \item Không nên expose trực tiếp database hoặc dịch vụ nội bộ ra Internet; nên dùng reverse proxy, VPN hoặc mạng riêng.
\end{itemize}

\subsection{Giao tiếp container--container}

\subsubsection*{Cách hoạt động}
Cách phổ biến nhất để các container giao tiếp với nhau là cho chúng cùng tham gia một user-defined bridge hoặc overlay network. Docker tích hợp DNS nội bộ, cho phép container gọi nhau bằng hostname hoặc service name, đặc biệt thuận tiện khi sử dụng Docker Compose hoặc Swarm.

\subsubsection*{Use case điển hình}
\begin{itemize}
  \item Kiến trúc 3-tier: container \texttt{web} gọi \texttt{api}, \texttt{api} gọi \texttt{db} trong cùng một network nội bộ.
  \item Kiến trúc microservices: nhiều service nhỏ trao đổi với nhau qua HTTP, gRPC hoặc message broker (Redis, RabbitMQ) trong cùng một mạng Docker.
\end{itemize}

\subsubsection*{Ưu điểm và nhược điểm}
\textbf{Ưu điểm:}
\begin{itemize}
  \item Cho phép tách ứng dụng thành nhiều service nhỏ, mỗi service là một container độc lập, nhưng vẫn giao tiếp được thông qua virtual network.
  \item Hỗ trợ service discovery qua DNS, không cần hard-code IP, chỉ cần dùng tên service.
\end{itemize}

\textbf{Nhược điểm:}
\begin{itemize}
  \item Khi số lượng service tăng, topology mạng trở nên phức tạp, việc debug giao tiếp giữa các container khó hơn.
  \item Các lỗi như sai network, subnet trùng, sai hostname thường gây lỗi kết nối “khó đoán” nếu không quen dùng các lệnh kiểm tra mạng của Docker.
\end{itemize}

\subsubsection*{Thách thức cấu hình và troubleshooting}
\begin{itemize}
  \item Lỗi thường gặp: container không ping/resolve được container khác do không cùng network hoặc DNS chưa đúng; cần cho chúng tham gia chung một user-defined network và kiểm tra hostname.
  \item Khi dùng nhiều loại network (bridge, overlay, macvlan) cùng lúc, việc route có thể rối; cần thường xuyên dùng \texttt{docker network ls} và \texttt{docker network inspect} để hiểu rõ topology.
\end{itemize}

\subsubsection*{Lưu ý bảo mật}
\begin{itemize}
  \item Mặc định, container trong cùng một network có thể trao đổi dữ liệu tự do; với dịch vụ nhạy cảm (như database), nên tách network và chỉ cho phép một số container truy cập.
  \item Nếu attacker chiếm được một container trong cùng network, họ có thể sniff hoặc tấn công các container khác; do đó cần kết hợp với firewall, TLS, và nguyên tắc \textit{least privilege}.
\end{itemize}

\end{document}


\section{Xây dựng ứng dụng phân bổ multi-container}


\subsection{Mô tả chung}

Hệ thống được thiết kế theo kiến trúc microservice, gồm hai dịch vụ độc lập:
\begin{itemize}
    \item \textbf{Gateway service}: cung cấp API hướng ra ngoài, lắng nghe tại cổng \texttt{8000}.
    \item \textbf{ML Worker service}: đảm nhiệm việc suy luận mô hình phân loại ``cat/dog'', lắng nghe tại cổng \texttt{5000}.
\end{itemize}

Cả hai dịch vụ đều được xây dựng trên nền tảng \texttt{FastAPI} và chạy trong các container riêng biệt, giúp việc triển khai, nâng cấp và mở rộng trở nên linh hoạt và ít phụ thuộc lẫn nhau.

\subsection{Kiến trúc và cơ chế giao tiếp}

Kiến trúc hệ thống theo hướng tách biệt rõ ràng giữa lớp API và lớp xử lý mô hình:

\begin{itemize}
    \item \textbf{Gateway} không chứa logic mô hình, mà đóng vai trò ``cửa ngõ'':
    \begin{itemize}
        \item Tiếp nhận request từ client.
        \item Điều phối request sang ML Worker.
        \item Đo lường và ghi nhận độ trễ giao tiếp.
    \end{itemize}
    \item \textbf{ML Worker} tập trung vào phần \textit{inference}:
    \begin{itemize}
        \item Nhận request từ Gateway.
        \item Thực hiện (hoặc mô phỏng) suy luận mô hình.
        \item Trả về kết quả dự đoán cho Gateway.
    \end{itemize}
    \item Hai dịch vụ giao tiếp với nhau thông qua HTTP nội bộ, với URL của ML Worker được cấu hình bằng biến môi trường \texttt{ML\_WORKER\_URL}. Cách cấu hình này giúp dễ dàng thay đổi địa chỉ triển khai (local, Docker, Kubernetes, v.v.) mà không cần sửa mã nguồn.
\end{itemize}

\subsection{Luồng xử lý yêu cầu}

Luồng xử lý chuẩn cho chức năng phân loại được mô tả như sau:

\begin{enumerate}
    \item Client gửi request \texttt{POST /classify} tới Gateway, kèm theo dữ liệu đầu vào cần phân loại (tuỳ vào cấu hình hiện tại).
    \item Gateway thực hiện gọi bất đồng bộ (\textit{async}) tới endpoint \texttt{POST /predict} của ML Worker, đồng thời đo thời gian khứ hồi (\textit{round-trip time}) giữa hai dịch vụ.
    \item Khi nhận được request \texttt{/predict}, ML Worker:
    \begin{itemize}
        \item Chờ khoảng 50\,ms để mô phỏng thời gian suy luận của mô hình.
        \item Sinh ngẫu nhiên một nhãn ``cat'' hoặc ``dog'' cùng với độ tin cậy \texttt{confidence = 0.9}.
        \item Trả về kết quả dạng JSON cho Gateway.
    \end{itemize}
    \item Gateway tổng hợp thông tin và trả kết quả cho client dưới dạng:
    \begin{verbatim}
{
  "prediction": "<cat|dog>",
  "remote_latency_ms": <thời_gian_ms>
}
    \end{verbatim}

\end{enumerate}

Ngoài ra, cả Gateway và ML Worker đều cung cấp endpoint \texttt{/health} để kiểm tra trạng thái hoạt động, hỗ trợ tích hợp với các hệ thống giám sát và cân bằng tải.

\subsection{Đánh giá kiến trúc và hướng phát triển}

\paragraph{Ưu điểm.}
\begin{itemize}
    \item Kiến trúc microservice rõ ràng, tách biệt trách nhiệm giữa lớp API và lớp mô hình.
    \item Dễ dàng thay thế ML Worker mô phỏng bằng mô hình ML thực mà không ảnh hưởng tới Gateway.
    \item Việc đóng gói bằng container giúp quy trình triển khai và nhân bản dịch vụ trở nên đơn giản, phù hợp với môi trường thực tế.
    \item Hệ thống đã hỗ trợ đo đạc độ trễ giữa Gateway và ML Worker, phục vụ tốt cho mục tiêu đánh giá hiệu năng mạng.
\end{itemize}

\paragraph{Hạn chế.}
\begin{itemize}
    \item Phần inference hiện tại chỉ là mô phỏng, chưa xử lý dữ liệu đầu vào thực tế.
    \item Chưa tích hợp các cơ chế bảo mật như xác thực, phân quyền hay mã hoá dữ liệu.
    \item Xử lý lỗi còn đơn giản, chưa có chiến lược retry chi tiết, timeout tuỳ biến hoặc ghi log một cách hệ thống.
\end{itemize}

\paragraph{Hướng phát triển.}
\begin{itemize}
    \item Bổ sung payload đầu vào đầy đủ cho endpoint \texttt{/classify} và triển khai mô hình ML thực tế trong ML Worker.
    \item Tích hợp cơ chế logging, monitoring (ví dụ: thu thập metric, log truy cập, cảnh báo khi dịch vụ lỗi).
    \item Hỗ trợ nhiều worker khác nhau cho các nhiệm vụ phân loại khác (ví dụ: đa nhãn, nhiều domain), và cấu hình Gateway để định tuyến đến worker tương ứng.
    \item Mở rộng các cơ chế bảo mật (auth, rate limiting, v.v.) cũng như chiến lược xử lý lỗi và phục hồi.
\end{itemize}










\section{Phân tích bảo mật container}

\section{Monitoring và Observability}

\section{Phản ánh}

Bài tập mạng này đã cung cấp một cái nhìn sâu sắc và toàn diện 
về kiến trúc và cơ chế xử lý ứng dụng của Docker, vượt ra ngoài mức 
độ triển khai cơ bản để đối mặt với các vấn đề vận hành và bảo mật thực tế.
 Trong quá trình thực hiện, người làm bài đã phải thử nghiệm nhiều phương 
 pháp chạy thử khác nhau, điều này giúp củng cố sự hiểu biết về vòng đời 
 và cấu hình của container. Thách thức lớn nhất ban đầu tập trung vào việc
  setup port và quản lý kết nối phức tạp giữa các container thông qua các
   địa chỉ IP nội bộ, đòi hỏi sự nắm vững về mô hình mạng Docker để đảm bảo luồng dữ 
liệu thông suốt. Sau khi hệ thống vận hành ổn định, bài tập đã chuyển 
sang trọng tâm là đào sâu vào các vấn đề bảo mật, mở ra nhiều góc nhìn
 mới mẻ. Cụ thể, yêu cầu bảo mật đặt ra là phải xử lý việc đặt tên IP và 
 ẩn giấu thông tin port (Port Obscurity) để giảm thiểu rủi ro bị lộ cấu 
 trúc mạng, đồng thời áp dụng mã hóa (encryption) cho tất cả các kết nối, đảm bảo tính bảo 
 mật và toàn vẹn của dữ liệu truyền tải giữa các thành phần. Cuối cùng, bài tập còn mang lại cơ hội quý 
 giá để làm việc với các công cụ giám sát và phân tích tiên tiến như Prometheus để theo dõi 
 các chỉ số hiệu suất của container và Wireshark để thực hiện phân tích gói tin sâu, kiểm tra hiệu 
 quả của việc mã hóa và gỡ lỗi mạng. Sự kết hợp giữa việc triển khai ứng dụng, khắc phục sự 
 cố kết nối, áp dụng các biện pháp bảo mật nghiêm ngặt, và sử dụng công cụ giám sát chuyên nghiệp 
 đã biến bài tập này thành một trải nghiệm thực hành phong phú và toàn diện trong lĩnh vực công nghệ container hiện đại.